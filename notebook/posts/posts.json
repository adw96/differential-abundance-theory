[
  {
    "path": "posts/2021-08-03-simulate-regression-example/",
    "title": "Simulate regression example",
    "description": "Simulate an example of how bias impacts a regression analysis.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-08-03",
    "categories": [],
    "contents": "\n\nContents\nSimulate data\nActual densities\nTaxonomic bias and measured densities\nCompute mean efficiencies\n\nPlots\nEstimated and actual densities\nRegression coefficients\nManuscript figure\n\n\n\n\n# library(here)\nlibrary(tidyverse)\n\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot(12))\n\nlibrary(ggdist)\nlibrary(ggbeeswarm)\n\nlibrary(speedyseq)\nlibrary(metacal)\n\nset.seed(42)\n\n\n\nSimulate data\n\n\nn_species <- 10\nn_samples <- 50\n\nspecies <- str_c(\"Species \", seq(n_species))\n\n\n\nActual densities\nLog abundances are independent and follow a simple linear model,\nlog density = a_0 + a_1 * X + epsilon\n\n\nn_samples <- 50\nx <- c(\n  rep(0, n_samples / 2),\n  rep(1, n_samples / 2)\n)\nX <- rbind(1, x)\n\nSigma <- diag(1, nrow = n_species)\nrownames(Sigma) <- colnames(Sigma) <- species\na_0 <- MASS::mvrnorm(\n  mu = rep(0, n_species), \n  Sigma = diag(1, nrow = n_species)\n)\na_1 <- MASS::mvrnorm(\n  mu = rep(0, n_species), \n  Sigma = diag(1, nrow = n_species)\n)\na <- cbind(a_0, a_1)\nnames(a_0) <- names(a_1) <- rownames(a) <- species\n\nepsilon <- MASS::mvrnorm(\n  n = n_samples,\n  mu = rep(0, n_species), \n  Sigma = diag(0.5, nrow = n_species)\n) %>%\n  t\n\ny <- a %*% X + epsilon\ncolnames(y) <- str_glue(\"sa{1:n_samples}\")\n\n\n\nFor the data frame of true coefficients, convert from log-e to log-2.\n\n\ntrue_coeffs <- list('(Intercept)' = a_0, x1 = a_1) %>%\n  map_dfr(enframe, \".otu\", \"truth\", .id = \"term\") %>%\n  mutate(across(truth, ~ . / log(2))) %>%\n  print\n\n\n#> # A tibble: 20 × 3\n#>    term        .otu         truth\n#>    <chr>       <chr>        <dbl>\n#>  1 (Intercept) Species 1  -0.0905\n#>  2 (Intercept) Species 2   2.91  \n#>  3 (Intercept) Species 3  -0.137 \n#>  4 (Intercept) Species 4   2.18  \n#>  5 (Intercept) Species 5  -0.153 \n#>  6 (Intercept) Species 6   0.583 \n#>  7 (Intercept) Species 7   0.913 \n#>  8 (Intercept) Species 8   0.524 \n#>  9 (Intercept) Species 9  -0.815 \n#> 10 (Intercept) Species 10  1.98  \n#> 11 x1          Species 1   1.90  \n#> 12 x1          Species 2  -3.52  \n#> 13 x1          Species 3  -3.83  \n#> 14 x1          Species 4  -0.410 \n#> 15 x1          Species 5   0.917 \n#> 16 x1          Species 6  -0.192 \n#> 17 x1          Species 7  -0.402 \n#> 18 x1          Species 8  -2.00  \n#> 19 x1          Species 9   3.30  \n#> 20 x1          Species 10  1.88\n\n\n\nsam <- tibble(.sample = colnames(y), x) %>%\n  mutate(across(x, factor))\nactual_dens <- phyloseq(\n  otu_table(y, taxa_are_rows = TRUE) %>% transform_sample_counts(exp),\n  sample_data(sam)\n)\n\n\n\n\n\nactual_dens %>%\n  as_tibble %>%\n  ggplot(aes(y = .otu, x = .abundance, fill = x)) +\n  scale_x_log10() +\n  stat_dots()\n\n\n\n\nTaxonomic bias and measured densities\nDraw efficiencies from a log normal distribution; set relative to the geometric mean efficiency.\n\n\nlog_efficiency <- MASS::mvrnorm(\n  mu = rep(0, n_species),\n  Sigma = diag(3, nrow = n_species)\n) %>%\n  # {. - min(.)}\n  {. - mean(.)}\nefficiency <- exp(log_efficiency)\n# names(efficiency) <- species\n\n\n\n\n\nlog_efficiency %>% summary\n\n\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#> -3.7952 -1.4314  0.0123  0.0000  0.9551  5.0904\n\nmax(efficiency) / min(efficiency)\n\n\n#> [1] 7226.731\n\nefficiency %>% qplot + scale_x_log10()\n\n\n\n\nTo create an association of log mean efficiency and the covariate, I will set set it so that the species with the largest slope coefficient also has the largest efficiency. This scenario is inspired by the leopold2020host and brooks2015thet experiments.\n\n\nidx_slope <- which.max(a_1)\nidx_eff <- which.max(efficiency)\nnames(efficiency) <- species\nnames(efficiency)[idx_eff] <- species[idx_slope]\nnames(efficiency)[idx_slope] <- species[idx_eff]\n\n\n\nData frame with all species parameters,\n\n\nspecies_params <- true_coeffs %>%\n  pivot_wider(names_from = term, values_from = truth) %>%\n  rename(intercept = '(Intercept)') %>%\n  left_join(efficiency %>% enframe('.otu', 'efficiency'), by = '.otu') %>%\n  mutate(log2_efficiency = log2(efficiency)) %>%\n  print\n\n\n#> # A tibble: 10 × 5\n#>    .otu       intercept     x1 efficiency log2_efficiency\n#>    <chr>          <dbl>  <dbl>      <dbl>           <dbl>\n#>  1 Species 1    -0.0905  1.90      0.0225          -5.48 \n#>  2 Species 2     2.91   -3.52      1.15             0.200\n#>  3 Species 3    -0.137  -3.83      0.213           -2.23 \n#>  4 Species 4     2.18   -0.410     0.0748          -3.74 \n#>  5 Species 5    -0.153   0.917     2.98             1.58 \n#>  6 Species 6     0.583  -0.192     0.339           -1.56 \n#>  7 Species 7     0.913  -0.402     0.892           -0.165\n#>  8 Species 8     0.524  -2.00      1.73             0.787\n#>  9 Species 9    -0.815   3.30    162.               7.34 \n#> 10 Species 10    1.98    1.88      9.62             3.27\n\n\n\nspecies_params %>%\n  ggplot(aes(x1, log2_efficiency)) +\n  geom_text(aes(label = str_extract(.otu, '[0-9]+')))\n\n\n\n\nQuestion: Is it true that the first species is driving the association?\nThe measured (i.e. estimated) proportions and densities are given by perturbing the actual densties by the efficiencies, and normalizing to proportions or to the original (correct) total.\n\n\nmeasured_prop <- actual_dens %>% perturb(efficiency)\nmeasured_dens <- actual_dens %>% perturb(efficiency, norm = \"keep\")\n\n\n\nCompute mean efficiencies\n\n\nmean_eff <- actual_dens %>%\n  transform_sample_counts(close_elts) %>%\n  perturb(efficiency, norm = \"none\") %>%\n  sample_sums %>%\n  enframe(\".sample\", \"mean_efficiency\") %>%\n  left_join(sam, by = \".sample\")\n\n\n\n\n\nmean_eff %>%\n  ggplot(aes(y = as.factor(x), x = mean_efficiency)) +\n  scale_x_log10() +\n  stat_dotsinterval()\n\n\n\n\nPlots\nEstimated and actual densities\n\n\nlvls <- a_1 %>% sort(decreasing = TRUE) %>% names\n\ndens <- bind_rows(\n  Actual = actual_dens %>% as_tibble,\n  Measured = measured_dens %>% as_tibble,\n  .id = 'type'\n) %>%\n  rename(density = .abundance) %>%\n  mutate(\n    log2_density = log2(density),\n    across(.otu, factor, levels = lvls)\n  )\n\n\n\n\n\np_species_all <- dens %>%\n  ggplot(aes(x, log2_density, color = type)) +\n  labs(y = \"Log density \") +\n  facet_grid(.otu~type, scales = \"fixed\") +\n  geom_quasirandom(alpha = 0.3, groupOnX = TRUE) +\n  # stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  stat_summary(geom = \"point\") +\n  stat_smooth(aes(x = as.integer(x)),\n    method = \"lm\", size = 0.9, fill = 'grey', se = FALSE\n  ) +\n  theme(legend.position = \"none\")\np_species_all \n\n\n\n\n\n\np_mean_eff <- mean_eff %>%\n  ggplot(aes(x, log2(mean_efficiency))) +\n  labs(y = \"Log efficiency \") +\n  geom_quasirandom(alpha = 0.3, groupOnX = TRUE) +\n  # stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  stat_summary(geom = \"point\") +\n  stat_smooth(aes(x = as.integer(x)),\n    method = \"lm\", size = 0.9, color = 'black', fill = 'grey', se = FALSE\n  )\np_mean_eff \n\n\n\n\n\n\np_mean_eff + p_species_all +\n  plot_layout(ncol = 1, heights = c(0.2, 1)) &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto()\n\n\n\n\nRegression coefficients\n\n\nlm_results_mean_eff <- mean_eff %>%\n  {lm(log2(mean_efficiency) ~ 1 + x, .)} %>%\n  broom::tidy(conf.int = TRUE)\n\n\n\n\n\nlm_results <- dens %>%\n  group_by(.otu, type) %>%\n  nest %>%\n  mutate(\n    fit = map(data, ~lm(log2_density ~ 1 + x, .)),\n    fit = map(fit, broom::tidy, conf.int = TRUE),\n  ) %>%\n  select(-data) %>%\n  unnest(fit) %>%\n  ungroup %>%\n  left_join(true_coeffs, by = c(\".otu\", \"term\"))\n\nlm_results_slope <- lm_results %>%\n  filter(term == \"x1\") %>%\n  mutate(\n    across(.otu, fct_reorder, estimate)\n  ) %>%\n  arrange(.otu)\n\n\n\n\n\n# params for arrows showing error\ndelta <- lm_results_mean_eff %>% filter(term == \"x1\") %>% pull(estimate)\nstart <- lm_results_slope %>% filter(type == 'Actual', .otu == 'Species 9') %>%\n  pull(estimate)\n\np_coef_ci <- lm_results_slope %>% \n  ggplot(aes(y = .otu, x = estimate, color = type)) +\n  labs(x = \"Log fold change\", y = NULL) +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  geom_pointinterval(aes(xmin = conf.low, xmax = conf.high)) +\n  theme(legend.position = 'top') +\n  guides(color = guide_legend(reverse = TRUE)) +\n  annotate(\n    geom = 'segment', color = \"darkgrey\",\n    arrow = grid::arrow(length = unit(0.1, \"inches\")), \n    x = start, xend = start - delta, \n    y = 10.5, yend = 10.5\n  ) +\n  coord_cartesian(clip = 'off')\n\np_coef_ci_with_true_coef <- p_coef_ci +\n  geom_point(data = ~filter(., type == \"Actual\"),\n    aes(x = truth),\n    color = 'black', shape = '+', size = 4)\n\np_coef_ci_mean_eff <- lm_results_mean_eff %>% \n  filter(term == \"x1\") %>%\n  ggplot(aes(y = \"Mean efficiency\", x = estimate)) +\n  expand_limits(\n    x = c(\n      min(lm_results_slope$conf.low), \n      max(lm_results_slope$conf.high)\n  )) +\n  labs(x = \"Log fold change\", y = NULL) +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  geom_point() +\n  annotate(\n    geom = 'segment', color = \"darkgrey\",\n    arrow = grid::arrow(length = unit(0.1, \"inches\")), \n    x = 0, xend = delta, \n    y = 1.0, yend = 1.0\n  )\n\np_coef_dot <- lm_results_slope %>% \n  ggplot(aes(y = type, x = estimate, fill = type)) +\n  labs(x = \"Log fold change\", y = \"Type\") +\n  geom_vline(xintercept = 0, color = \"grey\") +\n  stat_dots()\n\np_coef_ci_mean_eff / p_coef_ci_with_true_coef / p_coef_dot + \n  plot_layout(heights = c(0.2, 1, 0.3)) &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto()\n\n\n\n\nThe true coefficients fall within the ‘Actual’ CIs, confirming that our simulations worked. For the manuscript figure, we won’t include the true data-generating coefficients, since our aim is to illustrate the relationship between coefficients estimated on the ‘Actual’ and ‘Measured’ measurements.\nManuscript figure\nChose species that show the full range of qualitative behaviors in terms of the effect of taxonomic bias on the estimated slope coefficient.\nSpecies 9: Bias causes a substantial decrease in the magnitude of the slope\nSpecies 10: Bias causes a substantial decrease in the magnitude of the slope, such that the estimate is no longer distinguishable from zero.\nSpecies 5: Bias causes a sign error\nSpecies 7: Bias cases a small negative slope that would not have been distinguishable from zero to become significantly (in a biological and statistical sense) negative\nSpecies 2: Bias cases a substantially negative slope to become more negative (increased magnitude)\n\n\nspecies_to_plot <- str_c(\"Species \", c('9', '10', '5', '7', '2'))\np_species_focal <- p_species_all\np_species_focal$data <- p_species_focal$data %>% \n  filter(.otu %in% species_to_plot)\n\n# Bold these species in coeffcient CI plot\np_coef_ci1 <- p_coef_ci +\n  theme(\n    axis.text.y = element_text(\n      face = ifelse(levels(p_coef_ci$data$.otu) %in% species_to_plot, \n        \"bold\", \"plain\")\n    )\n  )\n\n# Set range of mean eff panel to match\nrng <- p_species_focal$data %>%\n  pull(log2_density) %>%\n  {max(.) - min(.)}\nm <- p_mean_eff$data %>% pull(mean_efficiency) %>% log2 %>% mean\np_mean_eff1 <- p_mean_eff + \n  expand_limits(y = c(m - rng/2, m + rng/2))\n\n\n\n\n\n(p_mean_eff1 + ggtitle(\"Mean efficiency\")) +\n  (p_coef_ci_mean_eff + ggtitle(\"LFC in mean efficiency\")) + \n  (p_species_focal + ggtitle(\"Actual and measured densities\\nof select species\")) + \n  (p_coef_ci1 + ggtitle(\"Estimated LFCs of all species\") +\n    theme(legend.box.margin = margin(b = -15))\n  ) + \n  plot_layout(ncol = 2, heights = c(0.2, 1)) +\n  plot_annotation(tag_levels = 'A') &\n  colorblindr::scale_color_OkabeIto() &\n  colorblindr::scale_fill_OkabeIto() &\n  theme(\n    plot.title = element_text(face = \"plain\")\n  )\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-08-03-simulate-regression-example/simulate-regression-example_files/figure-html5/unnamed-chunk-6-1.svg",
    "last_modified": "2021-09-15T14:19:19-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-10-vaginal-microbiome-example/",
    "title": "Hypothetical example of spurious fold changes in proportions in the vaginal microbiome",
    "description": "This doc develops a hypothetical example in which bias leads to a spurious differential abundance result. It is based on a real case of bias measured among three species of vaginally-associated bacteria.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-05-10",
    "categories": [],
    "contents": "\n\nContents\nSetup\nSimulate data\nPlots\nSession info\n\n\nChangelog\n2021-07-17: Cleaned up the doc and updated to use the cleaner code and include the caption from /article.Rmd\nSetup\n\n\nset.seed(42)\n\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  collapse = TRUE,\n  cache = FALSE,\n  echo = TRUE\n)\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot(12))\n\nclose_elts <- function(x) x / sum(x)\n\n\n\nSimulate data\n\n\nbias <- tibble(taxon = c(\"Lactobacillus\", \"Gardnerella\", \"Atopobium\", \"Spike-in\"),\n  efficiency = c(4.68, 0.16, 0.285, 1)) %>%\n  mutate(across(efficiency, ~. / min(.)))\n# efficiency associated with the targeted measurement of Lactobacillus\ntargeted_efficiency <- 2\na0 <- tribble(\n  ~taxon, ~timepoint, ~abundance,\n  \"Lactobacillus\", \"T1\", 5,\n  \"Lactobacillus\", \"T2\", 0.5,\n  \"Gardnerella\", \"T1\", 2,\n  \"Gardnerella\", \"T2\", 8,\n  \"Atopobium\", \"T1\", 3,\n  \"Atopobium\", \"T2\", 1.5,\n) %>%\n  # Shrink abundance to have similar scale as proportions\n  mutate(across(abundance, ~ . / max(.))) %>%\n  left_join(bias, by = \"taxon\") %>%\n  with_groups(timepoint, mutate,\n    total_abundance = sum(abundance),\n    proportion = close_elts(abundance),\n    biased_abundance = efficiency * abundance,\n    biased_proportion = close_elts(biased_abundance),\n    biased_count = biased_proportion * 1e3,\n    abundance_estimate_bulk = biased_proportion * total_abundance,\n    #> abundance_estimate_spikein = biased_count / biased_count[taxon == \"Spike-in\"],\n    abundance_estimate_targeted = biased_count * targeted_efficiency *\n      abundance[taxon == \"Lactobacillus\"] / biased_count[taxon == \"Lactobacillus\"],\n  )\na1 <- a0 %>%\n  select(-total_abundance) %>%\n  pivot_longer(-c(taxon, efficiency, timepoint), names_to = \"type\")\n# data frame for plots\nptb <- a1 %>%\n  filter(\n    type %in% c(\"proportion\", \"biased_proportion\"),\n  ) %>%\n  mutate(\n    across(type, fct_relevel, \"proportion\", \"biased_proportion\"),\n    across(type, fct_recode,\n      \"Actual\" = \"proportion\",\n      \"Observed\" = \"biased_proportion\"),\n  )\n\n\n\nPlots\nPanels showing the error in measurement and in differential abundance\n\n\nshared_layers <- list(\n  geom_path(aes(group = taxon),\n    arrow = grid::arrow(length = unit(0.15, \"inches\"))),\n  geom_point(size = 2),\n  scale_color_brewer(type = \"qual\", palette = 1, guide = \"none\"),\n  labs(y = \"Proportion\", color = \"Taxon\"),\n  scale_y_log10(),\n  coord_cartesian(clip = \"off\"),\n  # scale_y_log10(breaks = c(1e-2, 3e-2, 1e-1, 3e-1, 1)) +\n  expand_limits(y = 1e-2),\n  theme(plot.margin = unit(c(0, 1.3, 0, 0), units = \"in\"))\n)\n# How much to nudge the taxon labels and proportions\nnudge.taxon <- 0.48\nnudge.prop <- 0.24\n# In future iterations, consider labelling the taxa in both facets\np.meas <- ptb %>%\n  ggplot(aes(type, value, color = taxon)) +\n  facet_wrap(~timepoint, nrow = 1, scales = \"fixed\",\n    labeller = as_labeller(function(x) str_c(\"Time point \", x))\n  ) +\n  shared_layers +\n  geom_text(data = ~filter(., type == \"Actual\"),\n    aes(label = round(value, 2)), nudge_x = -nudge.prop) +\n  geom_text(data = ~filter(., type == \"Observed\"),\n    aes(label = round(value, 2)), nudge_x = nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\", type == \"Observed\"),\n    aes(label = taxon), nudge_x = nudge.taxon, hjust = 0) +\n  labs(\n    x = \"Type\",\n    title = \"Measurement error at each time point\"\n  )\np.fc <- ptb %>%\n  ggplot(aes(timepoint, value, color = taxon)) +\n  facet_wrap(~type, nrow = 1, scales = \"fixed\") +\n  shared_layers +\n  geom_text(data = ~filter(., timepoint == \"T1\"),\n    aes(label = round(value, 2)), nudge_x = -nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\"),\n    aes(label = round(value, 2)), nudge_x = nudge.prop) +\n  geom_text(data = ~filter(., timepoint == \"T2\", type == \"Observed\"),\n    aes(label = taxon), nudge_x = nudge.taxon, hjust = 0) +\n  labs(\n    x = \"Time point\",\n    title = \"Actual and observed fold changes\"\n  )\n\n\n\nPanel showing the efficiencies of individual taxa and the sample means\n\n\n# First, compute the mean efficiency, then join with the taxon efficiencies in\n# a table for plotting.\nsme <- a0 %>%\n  with_groups(timepoint, summarize, mean_efficiency = sum(proportion * efficiency))\nsme0 <- sme %>%\n  mutate(label = str_glue(\"mean ({timepoint})\")) %>%\n  select(label, efficiency = mean_efficiency)\nsme1 <- sme %>%\n  mutate(taxon = \"Mean\", type = \"Mean\") %>%\n  select(taxon, efficiency = mean_efficiency, timepoint, type)\nbias1 <- bias %>%\n  filter(taxon != \"Spike-in\") %>%\n  expand(nesting(taxon, efficiency), timepoint = c(\"T1\", \"T2\")) %>%\n  mutate(type = \"Taxon\")\nlvls = c(\"Atopobium\", \"Gardnerella\", \"Lactobacillus\", \"Mean\")\netb1 <- bind_rows(bias1, sme1) %>%\n  mutate(across(taxon, factor, levels = lvls))\n\nlvls = c(\"Gardnerella\", \"Atopobium\", \"Lactobacillus\")\nbias2 <- bias %>%\n  filter(taxon != \"Spike-in\") %>%\n  expand(nesting(taxon, efficiency), timepoint = c(\"T1\", \"T2\")) %>%\n  mutate(\n    type = \"Taxon\",\n    across(taxon, factor, levels = lvls),\n    x = as.integer(taxon)\n  ) %>%\n  left_join(sme, by = \"timepoint\")\n\nclrs <- c(RColorBrewer::brewer.pal(n = 3, \"Accent\"), rep(\"#585858\", 2))\np.eff <- bias2 %>%\n  ggplot(aes(x = x, y = efficiency, color = taxon)) +\n  geom_point(size = 2) +\n  geom_text(data = ~filter(., timepoint == \"T2\"),\n    aes(label = taxon), x = 3.3, hjust = 0) +\n  geom_segment(aes(xend = x, yend  = efficiency, y = mean_efficiency),\n    arrow = grid::arrow(length = unit(0.15, \"inches\"))) +\n  geom_segment(data = sme,\n    aes(x = 1, xend = 3, y = mean_efficiency, yend = mean_efficiency),\n    color = \"#585858\",\n    inherit.aes = FALSE) +\n  geom_text(data = sme0 %>% mutate(timepoint = \"T2\"),\n    aes(label = label, y = efficiency), x = 3.3, hjust = 0,\n    color = \"#585858\",\n    inherit.aes = FALSE) +\n  scale_color_manual(values = clrs) +\n  labs(y = \"Relative efficiency\", x = NULL, color = \"Taxon\",\n    title = \"Taxonomic bias of protocol\"\n  ) +\n  # Set the vertical span to match the other plots\n  scale_y_log10(limits = c(1, 100) / 2,\n    breaks = etb1$efficiency,\n    labels = signif(etb1$efficiency, 2)\n  ) +\n  xlim(c(0.0, 4)) +\n  facet_wrap(~timepoint, nrow = 1, scales = \"fixed\",\n    labeller = as_labeller(function(x) str_c(\"Time point \", x))\n  ) +\n  coord_cartesian(clip = \"off\") +\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    axis.title.x = element_blank(),\n    legend.position = \"none\",\n    plot.margin = unit(c(0, 1.0, 0, 0), units = \"in\")\n  )\n\n\n\nPlot as a multi-panel figure\n\n\np.meas + p.eff + p.fc + plot_spacer() + \n  plot_layout(byrow = TRUE, ncol = 2, widths = c(1, 0.6)) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nCaption (copied from main article version 47ce39c): Taxonomic bias can distort differential abundance results even when it is consistent for each taxon across samples. Panel A shows the actual and observed proportions for hypothetical community samples from two time points, which differ in their relative abundance of three taxa. Panel B shows taxonomic bias in terms of the relative efficiencies of the three taxa against the mean efficiency of each sample; the difference between the taxon’s efficiency and the sample’s mean (vertical arrows) determines the fold error seen in Panel A. Panel C rearranges the plot from Panel A to show the actual and observed fold changes between time points. The efficiencies of individual taxa were estimated by @mclaren2019cons from mock community data from @brooks2015thet. The abundances are hypothetical but inspired by observations from the human vaginal microbiome; see main text.\nSome ideas for improvement:\nExperiment with ways to make the connections even clearer between the efficiency differences and the error.\nTry making the arrows vertical, so that they are directly connected to the fold changes in proportion and in efficiency.\nCan also split the third plot into T1 and T2.\nMight consider changing “Time point T1” to “Sample S1”, to fit the primary language of the text.\nCan mention in the text that these could be samples from different women, or the same woman at different times.\nalso use a shape scale for the taxa, to give a second way besides color to distinguish them\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n#> ─ Session info ──────────────────────────────────────────────────────────────────\n#>  setting  value                       \n#>  version  R version 4.1.0 (2021-05-18)\n#>  os       Arch Linux                  \n#>  system   x86_64, linux-gnu           \n#>  ui       X11                         \n#>  language (EN)                        \n#>  collate  en_US.UTF-8                 \n#>  ctype    en_US.UTF-8                 \n#>  tz       America/New_York            \n#>  date     2021-07-17                  \n#> \n#> ─ Packages ──────────────────────────────────────────────────────────────────────\n#>  package      * version date       lib source        \n#>  assertthat     0.2.1   2019-03-21 [1] CRAN (R 4.0.0)\n#>  backports      1.2.1   2020-12-09 [1] CRAN (R 4.0.3)\n#>  base64enc      0.1-3   2015-07-28 [1] CRAN (R 4.0.0)\n#>  bookdown       0.22    2021-04-22 [1] CRAN (R 4.1.0)\n#>  broom          0.7.6   2021-04-05 [1] CRAN (R 4.0.5)\n#>  bslib          0.2.5.1 2021-05-18 [1] CRAN (R 4.1.0)\n#>  cellranger     1.1.0   2016-07-27 [1] CRAN (R 4.0.0)\n#>  cli            3.0.0   2021-06-30 [1] CRAN (R 4.1.0)\n#>  colorspace     2.0-2   2021-06-24 [1] CRAN (R 4.1.0)\n#>  cowplot      * 1.1.1   2020-12-30 [1] CRAN (R 4.0.4)\n#>  crayon         1.4.1   2021-02-08 [1] CRAN (R 4.0.4)\n#>  DBI            1.1.1   2021-01-15 [1] CRAN (R 4.0.4)\n#>  dbplyr         2.1.1   2021-04-06 [1] CRAN (R 4.0.5)\n#>  digest         0.6.27  2020-10-24 [1] CRAN (R 4.0.3)\n#>  distill        1.2     2021-01-13 [1] CRAN (R 4.1.0)\n#>  downlit        0.2.1   2020-11-04 [1] CRAN (R 4.0.3)\n#>  dplyr        * 1.0.7   2021-06-18 [1] CRAN (R 4.1.0)\n#>  ellipsis       0.3.2   2021-04-29 [1] CRAN (R 4.1.0)\n#>  evaluate       0.14    2019-05-28 [1] CRAN (R 4.0.0)\n#>  fansi          0.5.0   2021-05-25 [1] CRAN (R 4.1.0)\n#>  farver         2.1.0   2021-02-28 [1] CRAN (R 4.0.4)\n#>  forcats      * 0.5.1   2021-01-27 [1] CRAN (R 4.0.4)\n#>  fs             1.5.0   2020-07-31 [1] CRAN (R 4.0.2)\n#>  generics       0.1.0   2020-10-31 [1] CRAN (R 4.0.3)\n#>  ggplot2      * 3.3.5   2021-06-25 [1] CRAN (R 4.1.0)\n#>  glue           1.4.2   2020-08-27 [1] CRAN (R 4.0.2)\n#>  gtable         0.3.0   2019-03-25 [1] CRAN (R 4.0.0)\n#>  haven          2.4.1   2021-04-23 [1] CRAN (R 4.1.0)\n#>  here         * 1.0.1   2020-12-13 [1] CRAN (R 4.0.5)\n#>  highr          0.9     2021-04-16 [1] CRAN (R 4.1.0)\n#>  hms            1.1.0   2021-05-17 [1] CRAN (R 4.1.0)\n#>  htmltools      0.5.1.1 2021-01-22 [1] CRAN (R 4.0.3)\n#>  httr           1.4.2   2020-07-20 [1] CRAN (R 4.0.2)\n#>  jquerylib      0.1.4   2021-04-26 [1] CRAN (R 4.1.0)\n#>  jsonlite       1.7.2   2020-12-09 [1] CRAN (R 4.0.3)\n#>  knitr          1.33    2021-04-24 [1] CRAN (R 4.1.0)\n#>  labeling       0.4.2   2020-10-20 [1] CRAN (R 4.0.3)\n#>  lifecycle      1.0.0   2021-02-15 [1] CRAN (R 4.0.4)\n#>  lubridate      1.7.10  2021-02-26 [1] CRAN (R 4.0.4)\n#>  magrittr       2.0.1   2020-11-17 [1] CRAN (R 4.0.3)\n#>  modelr         0.1.8   2020-05-19 [1] CRAN (R 4.0.0)\n#>  munsell        0.5.0   2018-06-12 [1] CRAN (R 4.0.0)\n#>  nvimcom      * 0.9-102 2021-07-17 [1] local         \n#>  patchwork    * 1.1.1   2020-12-17 [1] CRAN (R 4.0.3)\n#>  pillar         1.6.1   2021-05-16 [1] CRAN (R 4.1.0)\n#>  pkgconfig      2.0.3   2019-09-22 [1] CRAN (R 4.0.0)\n#>  purrr        * 0.3.4   2020-04-17 [1] CRAN (R 4.0.0)\n#>  R6             2.5.0   2020-10-28 [1] CRAN (R 4.0.3)\n#>  RColorBrewer   1.1-2   2014-12-07 [1] CRAN (R 4.0.0)\n#>  Rcpp           1.0.7   2021-07-07 [1] CRAN (R 4.1.0)\n#>  readr        * 1.4.0   2020-10-05 [1] CRAN (R 4.0.3)\n#>  readxl         1.3.1   2019-03-13 [1] CRAN (R 4.0.0)\n#>  reprex         2.0.0   2021-04-02 [1] CRAN (R 4.0.5)\n#>  rlang          0.4.11  2021-04-30 [1] CRAN (R 4.1.0)\n#>  rmarkdown    * 2.8     2021-05-07 [1] CRAN (R 4.1.0)\n#>  rprojroot      2.0.2   2020-11-15 [1] CRAN (R 4.0.3)\n#>  rstudioapi     0.13    2020-11-12 [1] CRAN (R 4.0.3)\n#>  rvest          1.0.0   2021-03-09 [1] CRAN (R 4.0.5)\n#>  sass           0.4.0   2021-05-12 [1] CRAN (R 4.1.0)\n#>  scales         1.1.1   2020-05-11 [1] CRAN (R 4.0.0)\n#>  sessioninfo    1.1.1   2018-11-05 [1] CRAN (R 4.0.0)\n#>  stringi        1.6.2   2021-05-17 [1] CRAN (R 4.1.0)\n#>  stringr      * 1.4.0   2019-02-10 [1] CRAN (R 4.0.0)\n#>  tibble       * 3.1.2   2021-05-16 [1] CRAN (R 4.1.0)\n#>  tidyr        * 1.1.3   2021-03-03 [1] CRAN (R 4.0.4)\n#>  tidyselect     1.1.1   2021-04-30 [1] CRAN (R 4.1.0)\n#>  tidyverse    * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n#>  utf8           1.2.1   2021-03-12 [1] CRAN (R 4.0.5)\n#>  vctrs          0.3.8   2021-04-29 [1] CRAN (R 4.1.0)\n#>  withr          2.4.2   2021-04-18 [1] CRAN (R 4.0.5)\n#>  xfun           0.23    2021-05-15 [1] CRAN (R 4.1.0)\n#>  xml2           1.3.2   2020-04-23 [1] CRAN (R 4.0.0)\n#>  yaml           2.2.1   2020-02-01 [1] CRAN (R 4.0.0)\n#> \n#> [1] /home/michael/.local/lib/R/library\n#> [2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-05-10-vaginal-microbiome-example/vaginal-microbiome-example_files/figure-html5/vaginal-example-proportions-timepoints-1.svg",
    "last_modified": "2021-08-12T12:56:57-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-26-illustration-of-a-spurious-differential-abundance-result-due-to-bias/",
    "title": "Illustration of a spurious differential abundance result due to bias",
    "description": "Create illustration of a spurious differential abundance using the Leopold and Busby (2020) dataset.",
    "author": [
      {
        "name": "Michael R. McLaren",
        "url": {}
      }
    ],
    "date": "2021-04-26",
    "categories": [
      "bias sensitivity",
      "R",
      "ref:leopold2020host",
      "differential abundance"
    ],
    "contents": "\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0.9001'\n\n\n\nps.mock.pseudo <- ps.mock %>%\n  transform_sample_counts(function(x) x + 1)\nmc_fit <- estimate_bias(ps.mock.pseudo, mock_actual, boot = TRUE) %>% print\n\n\nA metacal bias fit.\n\nEstimated relative efficiencies:\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\nContains 1000 bootstrap replicates.\n\nbias <- coef(mc_fit) %>% print\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\n\n\nmc_fit.summary <- summary(mc_fit)\nprint(mc_fit.summary)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 9 × 4\n  taxon         estimate gm_mean gm_se\n  <chr>            <dbl>   <dbl> <dbl>\n1 Melampsora       8.75    8.77   1.06\n2 Dioszegia        0.295   0.294  1.10\n3 Epicoccum        1.01    1.01   1.50\n4 Fusarium         3.07    3.06   1.14\n5 Penicillium      0.223   0.223  1.09\n6 Cladosporium     0.899   0.898  1.13\n7 Trichoderma      0.578   0.578  1.09\n8 Alternaria       1.47    1.47   1.08\n9 Aureobasidium    0.738   0.736  1.12\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\n\n\ncoef_tb <- mc_fit.summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\n\n\nps.pseudo <- transform_sample_counts(ps, function(x) x + 1)\nps.pseudo.cal <- calibrate(ps.pseudo, bias) %>% print\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 567 samples ]:\nsample_data() Sample Data:        [ 567 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nSample mean efficiency across samples\nTo estimate the SMRE with formula sum_i A_i E_i, use the calibrated abundances.\n\n\nps0 <- ps.pseudo.cal %>%\n  prune_taxa(names(bias), .)\n\n\n\n\n\notu <- ps0 %>% otu_table %>% orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nsam0 <- sample_data(ps0) %>% \n  as(\"data.frame\") %>% \n  as_tibble(rownames = \"Sample\")\n\n\n\n\n\nsme <- otu %>% psmelt %>%\n  left_join(bias %>% enframe(\"OTU\", \"Efficiency\"), by = \"OTU\") %>%\n  group_by(Sample) %>%\n  summarize(SMRE = sum(Efficiency * Abundance)) %>%\n  left_join(sam0, by = \"Sample\") %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  )\n\n\n\nRegression analysis\nFirst let’s pick a subset of samples to work with.\n\n\nsam %>%\n  count(Samp_type, Timepoint)\n\n\n# A tibble: 4 × 3\n  Samp_type  Timepoint     n\n  <chr>      <fct>     <int>\n1 Experiment 1           250\n2 Experiment 2           298\n3 Mock       <NA>         10\n4 Single     <NA>          9\n\nsam %>%\n  filter(Samp_type == \"Experiment\") %>%\n  count(Treatment, Timepoint)\n\n\n# A tibble: 12 × 3\n   Treatment     Timepoint     n\n   <chr>         <fct>     <int>\n 1 Alternaria    1            52\n 2 Alternaria    2            53\n 3 Aureobasidium 1            50\n 4 Aureobasidium 2            48\n 5 Cladosporium  1            49\n 6 Cladosporium  2            48\n 7 Dioszegia     1            48\n 8 Dioszegia     2            49\n 9 Fusarium      1            49\n10 Fusarium      2            50\n11 Negative      1             2\n12 Negative      2            50\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Timepoint == 2) %>%\n  count(Region, Treatment)\n\n\n# A tibble: 12 × 3\n   Region Treatment         n\n   <chr>  <chr>         <int>\n 1 East   Alternaria       22\n 2 East   Aureobasidium    21\n 3 East   Cladosporium     19\n 4 East   Dioszegia        18\n 5 East   Fusarium         21\n 6 East   Negative         21\n 7 West   Alternaria       31\n 8 West   Aureobasidium    27\n 9 West   Cladosporium     29\n10 West   Dioszegia        31\n11 West   Fusarium         29\n12 West   Negative         29\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  count(Region, Timepoint)\n\n\n# A tibble: 4 × 3\n  Region Timepoint     n\n  <chr>  <fct>     <int>\n1 East   1           102\n2 East   2           101\n3 West   1           146\n4 West   2           147\n\nsam %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  with_groups(Genotype, summarize, n1 = sum(Timepoint == 1), n2 = sum(Timepoint == 2), tot = n())\n\n\n# A tibble: 12 × 4\n   Genotype    n1    n2   tot\n   <chr>    <int> <int> <int>\n 1 East-1      20    20    40\n 2 East-2      16    17    33\n 3 East-3      19    18    37\n 4 East-4      25    25    50\n 5 East-5      22    21    43\n 6 West-1      22    21    43\n 7 West-2      22    24    46\n 8 West-3      23    23    46\n 9 West-4      23    23    46\n10 West-5      18    17    35\n11 West-6      20    19    39\n12 West-7      18    20    38\n\nThe “Negative” treatment was not inoculated with commensals; let’s drop that from the analysis. Note that there are 2 more West genotypes adn thus more West than East samples.\nTime point\nAsks, how did taxa vary in proportion with the addition of Mel? Note, we expect the commensal taxa to typically decrease given that Mel successfully infects most plants.\nWant to do linear regression on the timepoint.\nstarting point - observed and calibrated proportions in the experiment samples; SME in the experiment samples\n\n\nps1.obs <- ps.pseudo %>%\n  subset_samples(Samp_type == \"Experiment\" & Treatment != \"Negative\") %>%\n  prune_taxa(mock_taxa, .) %>%\n  orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nps1.cal <- ps1.obs %>% calibrate(bias)\nsam1 <- sample_data(ps1.obs) %>% as(\"data.frame\")\nsme1 <- sme %>% filter(Sample %in% sample_names(ps1.obs)) %>% rename(Mean_efficiency = SMRE)\n\n\n\nNote the different numbers of samples at each timepoint Should consider more sophisticated resgression models.\n\n\nfit.obs <- lm(log2(otu_table(ps1.obs)) ~ Timepoint, data = sam1)\nfit.cal <- lm(log2(otu_table(ps1.cal)) ~ Timepoint, data = sam1)\nfit.sme <- lm(log2(Mean_efficiency) ~ Timepoint, data = sme1)\n\n\n\nCheck that the observed changes - the calibrated changes are off by the expected constant shift,\n\n\nt(coef(fit.obs) - coef(fit.cal))\n\n\n              (Intercept) Timepoint2\nMelampsora     2.60208447  -1.991951\nAureobasidium -0.96511376  -1.991951\nTrichoderma   -1.31867681  -1.991951\nFusarium       1.08940455  -1.991951\nPenicillium   -2.68941450  -1.991951\nAlternaria     0.02685515  -1.991951\nCladosporium  -0.68076501  -1.991951\nDioszegia     -2.28952043  -1.991951\nEpicoccum     -0.51768451  -1.991951\n\ncoef(fit.sme)\n\n\n(Intercept)  Timepoint2 \n  0.5269812   1.9919505 \n\n\n\ncoef(fit.obs) %>% t\n\n\n              (Intercept) Timepoint2\nMelampsora    -10.9999195  10.702851\nAureobasidium  -7.9294352  -3.681906\nTrichoderma    -9.4061811  -3.872543\nFusarium       -2.1926596  -5.089495\nPenicillium   -10.8867241  -2.555602\nAlternaria     -0.9593701  -4.074728\nCladosporium   -6.0294424  -3.585850\nDioszegia      -7.7191545  -5.463284\nEpicoccum      -2.3532764  -4.745944\n\ncoef(fit.cal) %>% t\n\n\n              (Intercept) Timepoint2\nMelampsora    -13.6020039 12.6948011\nAureobasidium  -6.9643215 -1.6899556\nTrichoderma    -8.0875043 -1.8805929\nFusarium       -3.2820642 -3.0975448\nPenicillium    -8.1973096 -0.5636511\nAlternaria     -0.9862252 -2.0827775\nCladosporium   -5.3486773 -1.5938999\nDioszegia      -5.4296340 -3.4713339\nEpicoccum      -1.8355919 -2.7539932\n\nThe effect of bias is significant; e.g. Aureobasidium and Trichoderma appear to decrease in proportion by 16X but actually decrease by 4X, and Penicillium appears to decrease by 5.9X but only decreases by 1.5X.\nCould use the case of Penicillium as our example.\n\n\n# Check expected relationship between coefficients on intercept and slope\nall.equal(\n  coef(fit.obs)[,\"Penicillium\"],\n  coef(fit.cal)[,\"Penicillium\"] + c(log2(bias[\"Penicillium\"]), 0) - coef(fit.sme)\n)\n\n\n[1] TRUE\n\n\n\ntb <- bind_rows(\n  Observed = psmelt(ps1.obs),\n  Calibrated = psmelt(ps1.cal),\n  .id = \"Type\"\n) %>%\n  mutate(across(Type, fct_relevel, \"Calibrated\")) %>%\n  rename(Proportion = Abundance)\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Type)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8) +\n  scale_color_brewer(type = \"qual\", palette = 6)\n\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_wrap(~Type)\n\n\n\n\nTODO: Add a panel with the sample mean efficiency\n\n\nsme1 %>%\n  ggplot(aes(y = log2(Mean_efficiency), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  )\n\n\n\n\nQuestion: For the purposes of illustration, might we want to find the host region or host genotype with the largest change in SME? Ok as long as we’re clear what we’re doing. Reducing the number of data points and biological variation might actually make things cleaner as well (or could use boxplots), since the point is not to dwell on all the variation, but rather just the average effect.\nfor paper, might be clearer to call “Corrected” instead of “Calibrated”.\nCan easily split graph by region or host genotype:\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Region)) +\n  geom_quasirandom(alpha = 0.4) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_wrap(~Type)\n\n\n\n\n\n\ntb %>%\n  filter(OTU == \"Penicillium\") %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  geom_quasirandom(alpha = 0.3) +\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_summary(fun.data = mean_cl_normal, fun.args = c(conf.int = 0.95), \n    geom = \"pointrange\") +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  facet_grid(Region~Type)\n\n\n\n\nNote that the 95% CIs are small and hard to see.\nWant to plot the sme’s with the change in proportion; make sure the y-axes have the same scale. One way to simplify this is to show the mean efficiency relative to the taxon in question; then it will give the difference between calibrated and observed.\n\n\nsme2 <- sme1 %>%\n  mutate(Mean_relative_efficiency = Mean_efficiency / bias[\"Penicillium\"]) %>%\n  rename(Proportion = Mean_relative_efficiency) %>%\n  mutate(Type = \"Mean relative efficiency\")\ntb1 <- tb %>%\n  filter(OTU == \"Penicillium\") %>%\n  bind_rows(sme2) %>%\n  mutate(across(Type, fct_relevel, c(\"Calibrated\", \"Observed\", \"Mean relative efficiency\")))\n\n\n\n\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_summary(fun.data = mean_cl_normal, fun.args = c(conf.int = 0.95), \n    geom = \"pointrange\"),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  )\n)\ntb1 %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint)) +\n  lyrs +\n  facet_grid(Region~Type)\n\n\n\n\n\n\ntb1 %>%\n  mutate(across(Type, fct_reorder, Proportion)) %>%\n  ggplot(aes(y = log2(Proportion), x = Timepoint, color = Type)) +\n  geom_quasirandom(alpha = 0.3) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.8, arrow = grid::arrow(length = unit(0.15, \"inches\"))\n  ) +\n  scale_color_brewer(type = \"qual\", palette = 2) +\n  guides(color = guide_legend(reverse = TRUE)) +\n  facet_grid(.~Region) +\n  geom_text(data = tibble(Region = \"West\"), x = 2.7, y = 5,\n    color = \"black\", size = 4.5, hjust = 0, vjust = 1,\n    label = \"Pathogen growth causes\\nmean efficiency to increase,\",\n  ) +\n  geom_text(data = tibble(Region = \"West\"), x = 2.7, y = -10,\n    color = \"black\", size = 4.5, hjust = 0, vjust = 1,\n    label = \"which leads to larger-than-\\nactual decreases in the\\nfocal taxon Penicillium.\",\n  ) +\n  coord_cartesian(xlim = c(1, 2), clip = \"off\") +\n  theme(\n    legend.position = \"top\",\n    plot.margin = margin(r = 2.5, unit = \"in\"),\n  ) +\n  plot_annotation(\n    title = \"Effect of bias on Penicillium differential abundance\"\n  )\n\n\n\n\nSummary:\nRegression of log2(Proportion) of the fungus Penicillium versus timepoint; timepoints 1 and 2 are pre- and post- challenge with the pathogen Melampsora. Data is split by the region the host plants are derived from.\nCalibrated proportions = Observed proportions in the real, experimental samples after adjustment for the bias measured in mock communities\nMean efficiency of each community is inferred by treating the calibrated proportions as the truth, and multiplying by efficiencies estimated from the mocks\nThe pathogen Melampsora has a high measurement efficiency; thus once it infects the plants, the mean efficiency of the sample increases (purple points). Efficiency is here taken as relative to the focal taxon Penicillium.\nWest plants tend to be more resistant to the pathogen, which likely explains why the mean efficiency doesn’t increase as much in the West plants\nPenicillium is observed to decrease in log proportion, in both the East and West plants. But the calibrated measurements show that it actually slightly increases in the East plants, and has a lesser decrease in the West plants than what was observed before bias correction.\nThe difference between the Calibrated and Observed data points and regression lines equals the regression line of the mean efficiency: Orange = Green + Purple; Green = Orange - Purple\nThe absolute error in regression coeffiecients is the same for all taxa. I picked Penicillium for illustration since it has the smallest observed decrease, which makes the error due to bias have a particularly significant impact. \n\n\n\nAlt. plot\n\n\ntb2 <- tb1 %>%\n  mutate(\n    log2_proportion = log2(Proportion),\n    across(Type, fct_relevel, c(\"Observed\", \"Calibrated\", \"Mean relative efficiency\")),\n    #> across(Type, fct_recode, Corrected = \"Calibrated\", Uncorrected = \"Observed\")\n  )\n\n\n\nLet’s show the calibrated, observed, and mean efficiency side by side, similar to my initial explanatory plot.\nQuestion: How to get the same y-axis range in each facet? We need to determine what we want the min and max y values for each facet to be. Choose so that the range in each panel equals the max data range for any one panel, and center the data range of each panel within the plot range.\n\n\nyr <- tb2 %>%\n  with_groups(c(Region, Type), summarize, \n    across(log2_proportion, c(min = min, max = max), .names =  \"data_{.fn}\")\n ) %>%\n  mutate(\n    data_range = data_max - data_min,\n    data_mid = (data_max + data_min) / 2,\n    y_min = data_mid - max(data_range) / 2,\n    y_max = data_mid + max(data_range) / 2\n  ) %>%\n  print\n\n\n# A tibble: 6 × 8\n  Region Type      data_min data_max data_range data_mid   y_min y_max\n  <chr>  <fct>        <dbl>    <dbl>      <dbl>    <dbl>   <dbl> <dbl>\n1 East   Observed    -14.9     -8.66       6.26   -11.8  -16.2   -7.41\n2 East   Calibrat…   -12.2     -5.96       6.22    -9.07 -13.5   -4.69\n3 East   Mean rel…     2.48     5.27       2.79     3.87  -0.510  8.26\n4 West   Observed    -14.9     -6.16       8.77   -10.5  -14.9   -6.16\n5 West   Calibrat…   -11.3     -3.58       7.76    -7.46 -11.8   -3.07\n6 West   Mean rel…     2.47     5.26       2.79     3.87  -0.515  8.25\n\nstopifnot(yr %>% {sd((.$y_max - .$y_min))} < 1e-14)\nyr.long <- yr %>%\n  pivot_longer(c(y_min, y_max))\n\n\n\n\n\ntb2 %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  geom_quasirandom(alpha = 0.3) +\n  geom_blank(data = yr.long, aes(y = value, x = 1)) +\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3) +\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.9, arrow = grid::arrow(length = unit(0.15, \"inches\")), color = \"red\"\n  ) +\n  scale_color_brewer(type = \"qual\", palette = 2) +\n  guides(color = guide_legend(reverse = TRUE)) +\n  facet_wrap(Region~Type, scales = \"free_y\") +\n  coord_cartesian(xlim = c(1, 2), clip = \"off\") +\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)) +\n  labs(y = \"log2(Proportion)\")\n\n\n\n\n\n\ntext_tb <- yr %>%\n  filter(Type %in% c(\"Calibrated\", \"Observed\")) %>%\n  mutate(\n    text = case_when(\n      Type == \"Observed\" ~ \"=\",\n      Type == \"Calibrated\" ~ \"–\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\n\n#> Label \"Calibrated\" as \"Actual\" for purposes of illustration?\nlblr <- function(labels) {\n  labels %>% pull(1) %>% fct_recode(Actual = \"Calibrated\") %>% as.character %>% list\n}\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\"),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    #> arrow = grid::arrow(length = unit(0.15, \"inches\")),\n    size = 0.9, color = \"red\"\n  ),\n  scale_color_brewer(type = \"qual\", palette = 2),\n  guides(color = guide_legend(reverse = TRUE)),\n  facet_wrap(~Type, scales = \"free_y\", labeller = lblr),\n  #> theme_minimal_hgrid(),\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)),\n  theme(\n    plot.title = element_text(face = \"plain\"),\n    legend.position = \"top\",\n    panel.spacing.x = unit(0.75, \"in\")\n  ),\n  labs(y = \"log2(Proportion)\"),\n  # Corrected = Observed - Mean relative efficiency\n  coord_cartesian(xlim = c(1, 2), clip = \"off\")\n)\np1 <- tb2 %>%\n  filter(Region == \"East\") %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  geom_blank(data = yr.long %>% filter(Region == \"East\"), aes(y = value, x = factor(1))) +\n  labs(title = \"Eastern genotypes: Bias causes sign error\") +\n  geom_text(\n    data = text_tb %>% filter(Region == \"East\"),\n    aes(y = y, label = text),\n    x = 2.9,\n    color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  )\np2 <- tb2 %>%\n  filter(Region == \"West\") %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  geom_blank(data = yr.long %>% filter(Region == \"West\"), aes(y = value, x = factor(1))) +\n  labs(title = \"Western genotypes: Bias causes magnitude error\") +\n  geom_text(\n    data = text_tb %>% filter(Region == \"West\"),\n    aes(y = y, label = text),\n    x = 2.9,\n    color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  )\n\n\n\n\n\np1 / p2 + \n  plot_annotation(\n    #> title = \"Effect of bias on Penicillium differential abundance\",\n    tag_levels = \"A\"\n  )\n\n\n\n\nThis ^ is my favorite so far\n\n\n\nTODO:\nChange y label to log2(value) and adding “proportion” to the two proportion facets\nChange back to “Calibrated proportion” and “Observed proportion”?\nSlightly increase spacing between patchwork panels (rows)\nSwap positions of calibrated and uncalibrated so that the equation is correct: Observed = Actual - Mean efficiency\nalternate approach using 2-d facet wrap:\n\n\nsymbol_labels <- yr %>%\n  filter(Type %in% c(\"Calibrated\", \"Observed\")) %>%\n  mutate(\n    text = case_when(\n      Type == \"Observed\" ~ \"=\",\n      Type == \"Calibrated\" ~ \"–\",\n      #> Type == \"Mean relative efficiency\" & Region == \"East\" ~ \"Eastern\\ngenotypes\",\n      #> Type == \"Mean relative efficiency\" & Region == \"West\" ~ \"Western\\ngenotypes\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\nregion_labels <- yr %>%\n  filter(Type == \"Mean relative efficiency\") %>%\n  mutate(\n    text = case_when(\n      Region == \"East\" ~ \"Eastern genotypes\\n\\nBias causes\\nsign error\",\n      Region == \"West\" ~ \"Western genotypes\\n\\nBias causes\\nmagnitude error\",\n    ),\n    y = y_min + (y_max - y_min) / 2\n  )\n\nlyrs <- list(\n  geom_quasirandom(alpha = 0.3),\n  #> geom_blank(data = yr, aes(y = y_min, x = factor(1))),\n  #> geom_blank(data = yr, aes(y = y_max, x = factor(1))),\n  geom_blank(data = yr.long, aes(y = value, x = 1)),\n  stat_summary(fun = \"mean\", geom = \"point\", size = 3),\n  stat_smooth(aes(x = as.integer(Timepoint)), method = \"lm\", geom = \"line\",\n    size = 0.9, arrow = grid::arrow(length = unit(0.15, \"inches\")), color = \"red\"\n  ),\n  scale_color_brewer(type = \"qual\", palette = 2),\n  guides(color = guide_legend(reverse = TRUE)),\n  #> facet_wrap(~Type, scales = \"free_y\"),\n  #> theme_minimal_hgrid(),\n  scale_y_continuous(breaks = seq(-20, 10, by = 2)),\n  labs(y = \"log2(Proportion)\"),\n  # Calibrated = Observed - Mean relative efficiency\n  geom_text(\n    data = symbol_labels,\n    aes(y = y, label = text),\n    x = 2.9, color = \"black\", size = 8, hjust = 0.5, vjust = 0.5,\n  ),\n  geom_text(\n    data = region_labels,\n    aes(y = y, label = text),\n    x = 2.8, color = \"black\", size = 4.8, hjust = 0, vjust = 0.5,\n  ),\n  coord_cartesian(xlim = c(1, 2), clip = \"off\"),\n  theme(\n    legend.position = \"top\",\n    panel.spacing.x = unit(0.75, \"in\"),\n    plot.margin = margin(r = 1.75, unit = \"in\")\n  )\n)\n\n# labeller assuming first col is region, second is type\nlblr <- function(labels) {\n  labels %>% pull(2) %>% as.character %>% list\n}\n\ntb2 %>%\n  ggplot(aes(y = log2_proportion, x = Timepoint)) +\n  lyrs +\n  facet_wrap(Region~Type, scales = \"free_y\", \n    labeller = lblr\n    #> labeller = labeller(Region = NULL, .multi_line = FALSE),\n    #> strip.position = \"right\"\n  )\n\n\n\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.1.0 (2021-05-18)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-07-28                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package          * version    date       lib source                           \n ade4               1.7-17     2021-06-17 [1] CRAN (R 4.1.0)                   \n ape                5.5        2021-04-25 [1] CRAN (R 4.1.0)                   \n assertthat         0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports          1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n base64enc          0.1-3      2015-07-28 [1] CRAN (R 4.0.0)                   \n beeswarm           0.4.0      2021-06-01 [1] CRAN (R 4.1.0)                   \n Biobase            2.52.0     2021-05-19 [1] Bioconductor                     \n BiocGenerics       0.38.0     2021-05-19 [1] Bioconductor                     \n biomformat         1.20.0     2021-05-19 [1] Bioconductor                     \n Biostrings         2.60.0     2021-05-19 [1] Bioconductor                     \n bitops             1.0-7      2021-04-24 [1] CRAN (R 4.1.0)                   \n broom            * 0.7.8      2021-06-24 [1] CRAN (R 4.1.0)                   \n bslib              0.2.5.1    2021-05-18 [1] CRAN (R 4.1.0)                   \n cellranger         1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n checkmate          2.0.0      2020-02-06 [1] CRAN (R 4.0.2)                   \n cli                3.0.1      2021-07-17 [1] CRAN (R 4.1.0)                   \n cluster            2.1.2      2021-04-17 [2] CRAN (R 4.1.0)                   \n codetools          0.2-18     2020-11-04 [2] CRAN (R 4.1.0)                   \n colorspace         2.0-2      2021-06-24 [1] CRAN (R 4.1.0)                   \n cowplot          * 1.1.1      2020-12-30 [1] CRAN (R 4.0.4)                   \n crayon             1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table         1.14.0     2021-02-21 [1] CRAN (R 4.0.4)                   \n DBI                1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr             2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest             0.6.27     2020-10-24 [1] CRAN (R 4.0.3)                   \n distill            1.2        2021-01-13 [1] CRAN (R 4.1.0)                   \n downlit            0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr            * 1.0.7      2021-06-18 [1] CRAN (R 4.1.0)                   \n ellipsis           0.3.2      2021-04-29 [1] CRAN (R 4.1.0)                   \n evaluate           0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi              0.5.0      2021-05-25 [1] CRAN (R 4.1.0)                   \n farver             2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n forcats          * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach            1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n foreign            0.8-81     2020-12-22 [2] CRAN (R 4.1.0)                   \n Formula            1.2-4      2020-10-16 [1] CRAN (R 4.0.3)                   \n fs                 1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics           0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                   \n GenomeInfoDb       1.28.0     2021-05-19 [1] Bioconductor                     \n GenomeInfoDbData   1.2.6      2021-05-31 [1] Bioconductor                     \n ggbeeswarm       * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2          * 3.3.5      2021-06-25 [1] CRAN (R 4.1.0)                   \n glue               1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gridExtra          2.3        2017-09-09 [1] CRAN (R 4.0.2)                   \n gtable             0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven              2.4.1      2021-04-23 [1] CRAN (R 4.1.0)                   \n here               1.0.1      2020-12-13 [1] CRAN (R 4.0.5)                   \n highr              0.9        2021-04-16 [1] CRAN (R 4.1.0)                   \n Hmisc              4.5-0      2021-02-28 [1] CRAN (R 4.0.4)                   \n hms                1.1.0      2021-05-17 [1] CRAN (R 4.1.0)                   \n htmlTable          2.2.1      2021-05-18 [1] CRAN (R 4.1.0)                   \n htmltools          0.5.1.1    2021-01-22 [1] CRAN (R 4.0.3)                   \n htmlwidgets        1.5.3      2020-12-10 [1] CRAN (R 4.0.3)                   \n httr               1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph             1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                   \n IRanges            2.26.0     2021-05-19 [1] Bioconductor                     \n iterators          1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jpeg               0.1-9      2021-07-24 [1] CRAN (R 4.1.0)                   \n jquerylib          0.1.4      2021-04-26 [1] CRAN (R 4.1.0)                   \n jsonlite           1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr              1.33       2021-04-24 [1] CRAN (R 4.1.0)                   \n labeling           0.4.2      2020-10-20 [1] CRAN (R 4.0.3)                   \n lattice            0.20-44    2021-05-02 [2] CRAN (R 4.1.0)                   \n latticeExtra       0.6-29     2019-12-19 [1] CRAN (R 4.0.0)                   \n lifecycle          1.0.0      2021-02-15 [1] CRAN (R 4.0.4)                   \n lubridate          1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                   \n magrittr           2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS               7.3-54     2021-05-03 [2] CRAN (R 4.1.0)                   \n Matrix             1.3-3      2021-05-04 [2] CRAN (R 4.1.0)                   \n metacal          * 0.2.0.9001 2021-07-16 [1] Github (mikemc/metacal@a7a87a1)  \n mgcv               1.8-35     2021-04-18 [2] CRAN (R 4.1.0)                   \n modelr             0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest           2.48.0     2021-05-19 [1] Bioconductor                     \n munsell            0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme               3.1-152    2021-02-04 [2] CRAN (R 4.1.0)                   \n nnet               7.3-16     2021-05-03 [2] CRAN (R 4.1.0)                   \n nvimcom          * 0.9-102    2021-07-17 [1] local                            \n patchwork        * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute            0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq         * 1.36.0     2021-05-19 [1] Bioconductor                     \n pillar             1.6.1      2021-05-16 [1] CRAN (R 4.1.0)                   \n pkgconfig          2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr               1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n png                0.1-7      2013-12-03 [1] CRAN (R 4.0.0)                   \n purrr            * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6                 2.5.0      2020-10-28 [1] CRAN (R 4.0.3)                   \n RColorBrewer       1.1-2      2014-12-07 [1] CRAN (R 4.0.0)                   \n Rcpp               1.0.7      2021-07-07 [1] CRAN (R 4.1.0)                   \n RCurl              1.98-1.3   2021-03-16 [1] CRAN (R 4.0.5)                   \n readr            * 2.0.0      2021-07-20 [1] CRAN (R 4.1.0)                   \n readxl             1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex             2.0.0      2021-04-02 [1] CRAN (R 4.0.5)                   \n reshape2           1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5              2.36.0     2021-05-19 [1] Bioconductor                     \n rhdf5filters       1.4.0      2021-05-19 [1] Bioconductor                     \n Rhdf5lib           1.14.0     2021-05-19 [1] Bioconductor                     \n rlang              0.4.11     2021-04-30 [1] CRAN (R 4.1.0)                   \n rmarkdown        * 2.9        2021-06-15 [1] CRAN (R 4.1.0)                   \n rpart              4.1-15     2019-04-12 [2] CRAN (R 4.1.0)                   \n rprojroot          2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi         0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest              1.0.0      2021-03-09 [1] CRAN (R 4.0.5)                   \n S4Vectors          0.30.0     2021-05-19 [1] Bioconductor                     \n sass               0.4.0      2021-05-12 [1] CRAN (R 4.1.0)                   \n scales             1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo        1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq        * 0.5.3.9018 2021-06-29 [1] Github (mikemc/speedyseq@ceb941f)\n stringi            1.7.3      2021-07-16 [1] CRAN (R 4.1.0)                   \n stringr          * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival           3.2-11     2021-04-26 [2] CRAN (R 4.1.0)                   \n tibble           * 3.1.3      2021-07-23 [1] CRAN (R 4.1.0)                   \n tidyr            * 1.1.3      2021-03-03 [1] CRAN (R 4.0.4)                   \n tidyselect         1.1.1      2021-04-30 [1] CRAN (R 4.1.0)                   \n tidyverse        * 1.3.1      2021-04-15 [1] CRAN (R 4.1.0)                   \n tzdb               0.1.2      2021-07-20 [1] CRAN (R 4.1.0)                   \n useful             1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8               1.2.2      2021-07-24 [1] CRAN (R 4.1.0)                   \n vctrs              0.3.8      2021-04-29 [1] CRAN (R 4.1.0)                   \n vegan              2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor              0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr              2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun               0.24       2021-06-15 [1] CRAN (R 4.1.0)                   \n xml2               1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector            0.32.0     2021-05-19 [1] Bioconductor                     \n yaml               2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc           1.38.0     2021-05-19 [1] Bioconductor                     \n\n[1] /home/michael/.local/lib/R/library\n[2] /usr/lib/R/library\n\n\n\n\n",
    "preview": "posts/2021-04-26-illustration-of-a-spurious-differential-abundance-result-due-to-bias/index_files/figure-html5/unnamed-chunk-2-1.svg",
    "last_modified": "2021-09-15T14:18:05-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-11-12-leopold2020host-bias-sensitivity/",
    "title": "Exploring the effect of bias in Leopold and Busby (2020)\n",
    "description": {},
    "author": [
      {
        "name": "Michael McLaren",
        "url": {}
      }
    ],
    "date": "2019-10-21",
    "categories": [
      "bias sensitivity",
      "R",
      "ref:leopold2020host"
    ],
    "contents": "\n\nContents\nSetup\nSample mean efficiency across samples\nAlt plot\nCheck errors in FCs\nmock samples\nExperiment samples\n\n\nSession info\n\nAnalysis of bias in Leopold and Busby (2020).\nSetup\n\n\n# Tools for microbiome data\nlibrary(speedyseq)\n# Tools for general purpose data manipulation and plotting\nlibrary(tidyverse)\n# ggplot helpers\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(patchwork)\ntheme_set(theme_cowplot())\n\n# stats helpers\nlibrary(broom)\n\nlibrary(metacal); packageVersion(\"metacal\")\n\n\n[1] '0.2.0'\n\n\n\nps.mock.pseudo <- ps.mock %>%\n  transform_sample_counts(function(x) x + 1)\nmc_fit <- estimate_bias(ps.mock.pseudo, mock_actual, boot = TRUE) %>% print\n\n\nA metacal bias fit.\n\nEstimated relative efficiencies:\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\nContains 1000 bootstrap replicates.\n\nbias <- coef(mc_fit) %>% print\n\n\n   Melampsora     Dioszegia     Epicoccum      Fusarium   Penicillium \n    8.7486819     0.2947290     1.0064648     3.0660596     0.2233792 \n Cladosporium   Trichoderma    Alternaria Aureobasidium \n    0.8988898     0.5776648     1.4679841     0.7380894 \n\n\n\nmc_fit.summary <- summary(mc_fit)\nprint(mc_fit.summary)\n\n\nSummary of a metacal bias fit.\n\nEstimated relative efficiencies:\n# A tibble: 9 x 4\n  taxon         estimate gm_mean gm_se\n  <chr>            <dbl>   <dbl> <dbl>\n1 Melampsora       8.75    8.76   1.06\n2 Dioszegia        0.295   0.295  1.10\n3 Epicoccum        1.01    0.995  1.50\n4 Fusarium         3.07    3.08   1.14\n5 Penicillium      0.223   0.224  1.09\n6 Cladosporium     0.899   0.903  1.13\n7 Trichoderma      0.578   0.579  1.09\n8 Alternaria       1.47    1.46   1.08\n9 Aureobasidium    0.738   0.736  1.12\n\nGeometric standard error estimated from 1000 bootstrap replicates.\n\n\n\ncoef_tb <- mc_fit.summary$coefficients\ncoef_tb %>%\n  mutate(taxon = fct_reorder(taxon, estimate)) %>%\n  ggplot(aes(taxon, estimate, \n      ymin = estimate / gm_se^2, ymax = estimate * gm_se^2)) +\n  geom_hline(yintercept = 1, color = \"grey\") +\n  geom_pointrange() +\n  scale_y_log10() +\n  coord_flip()\n\n\n\n\n\n\nps.pseudo <- transform_sample_counts(ps, function(x) x + 1)\nps.pseudo.cal <- calibrate(ps.pseudo, bias) %>% print\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 567 samples ]:\nsample_data() Sample Data:        [ 567 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nSample mean efficiency across samples\nTo estimate the SMRE with formula sum_i A_i E_i, use the calibrated abundances.\n\n\nps0 <- ps.pseudo.cal %>%\n  prune_taxa(names(bias), .)\n\n\n\n\n\notu <- ps0 %>% otu_table %>% orient_taxa(as = \"cols\") %>%\n  transform_sample_counts(close_elts)\nsam0 <- sample_data(ps0) %>% \n  as(\"data.frame\") %>% \n  as_tibble(rownames = \"Sample\")\n\n\n\n\n\nsme <- otu %>% psmelt %>%\n  left_join(bias %>% enframe(\"OTU\", \"Efficiency\"), by = \"OTU\") %>%\n  group_by(Sample) %>%\n  summarize(SMRE = sum(Efficiency * Abundance)) %>%\n  left_join(sam0, by = \"Sample\") %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  )\n\n\n\n\n\nrange(sme$SMRE)\n\n\n[1] 0.2236076 8.7034225\n\nrange(bias)\n\n\n[1] 0.2233792 8.7486819\n\n\n\np1 <- ggplot(sme, aes(SMRE, fill = Samp_type)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  expand_limits(x = range(bias)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\",\n    fill = \"Sample type\"\n  )\np1 +\n  plot_annotation(\n    title = \"Distribution of sample mean relative efficiencies\",\n  )\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020host-smre-distribution.svg\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.png\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\n\n\n\nIn this case, the bimodal distribution is likely driven by the high proportion of Melampsora (pathogen) in ~half the samples.\nTODO: check this hypothesis. by making a histogram of melampspora %, and a scatterplot of the melamspora vs. SMRE. Can do with facet matrix from ggforce\n\n\nmel <- otu %>%\n  prune_taxa(\"Melampsora\", .) %>%\n  psmelt %>%\n  select(-OTU, Melampsora = Abundance)\nsme0 <- left_join(sme, mel, by = \"Sample\")\n\n\n\n\n\n# p2 <- ggplot(sme0, aes(SMRE, fill = Melampsora)) +\np2 <- ggplot(sme0, aes(y = Melampsora, x = SMRE, color = Samp_type)) +\n  geom_point() +\n  # annotate(\"point\", y = 1, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  # scale_y_sqrt() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  expand_limits(x = range(bias)) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Melampsora proportion\",\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\",\n    color = \"Sample type\"\n  )\np2\n\n\n\n\n\n\n(p1 + ggtitle(\"Distribution of the mean efficiency across samples\")) / \n  (p2 + ggtitle(\"Melampsora proportion vs. mean efficiency\")) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020host-smre-distribution.svg\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.pdf\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\nggsave(\"/tmp/leopold2020host-smre-distribution.png\", units = \"in\",\n  width = 6, height = 6, scale = 1.5)\n\n\n\nNote, the high-Mel samples are the timepoint 2 samples, and were not used for some (all?) of his analysis due to the dominance of Mel. Let’s check this out,\n\n\nsme %>%\n  mutate(\n    across(Timepoint, as.factor),\n    across(Timepoint, fct_explicit_na, \"Other\"),\n  ) %>%\n  # filter(Samp_type == \"Experiment\") %>%\n  ggplot(aes(SMRE, fill = Timepoint)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  expand_limits(x = range(bias)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  )\n\n\n\n\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\") %>%\n  ggplot(aes(SMRE, fill = Treatment)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Region)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nCan see that Eastern genotypes more susceptible (more Mel and higher SME)\nAre some western genotypes less susceptible?\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Region == \"West\",\n    Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Genotype)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nEastern?\n\n\nsme %>%\n  filter(Samp_type == \"Experiment\", Region == \"East\",\n    Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Genotype)) +\n  geom_histogram() +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  ) +\n  facet_wrap(~Timepoint, ncol = 1)\n\n\n\n\nAlt plot\nMight be better to just focus on the treated experimental samples; can note that the bimodal distribution in SMRE is due to the presence of Mel in the timepoint 2, and thus we’d mess up our AA inferences if we tried to infer the change in AA after Mel introduction. We might also (if were were analyzing timepoint 2 samples)\nActually, including the bias values serves the important purpose of showing how the SME varies less than the efficiencies. For that reason it could even be worth having the single-isolate samples, though seems unneeded.\nPoints\nSME varies less across samples than efficiencies vary across taxa\nSME much greater after rusting (timepoint 2) -> it will look like the growth of the pathogen suppressed the proportion and absolute abundance of the colonizers 5-6X more than it actually did\nThe Mel prop and hence the SME varies significantly in the timepoint 2 samples. This may lead to systematic errors in certain inferences. E.g., if host genotype affects Mel and another taxon, that other taxon’s value will be distorted (and, I think, the effect on Mel will be inflated).\nAs an example, think through the case of more resistant host genotypes\nMight also consider the taxa found to suppress Mel; see paper\n\n\n\np1.1 <- sme %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(SMRE, fill = Timepoint)) +\n  geom_histogram() +\n  annotate(\"point\", y = 200, x = bias, color = \"black\", shape = \"|\", size = 7) +\n  expand_limits(x = range(bias)) +\n  scale_x_log10() +\n  scale_y_sqrt(breaks = c(1, 10, 50, 100, 200)) +\n  scale_fill_brewer(type = \"qual\") +\n  labs(\n    # x = \"Sample mean relative efficiency (SMRE)\",\n    x = \"Mean efficiency\", \n    y = \"Number of samples\"\n  )\np2.1 <- sme0 %>%\n  filter(Samp_type == \"Experiment\", Treatment != \"Negative\") %>%\n  ggplot(aes(y = Melampsora, x = SMRE, color = Timepoint)) +\n  geom_point() +\n  expand_limits(x = range(bias)) +\n  scale_x_log10() +\n  # scale_y_sqrt() +\n  scale_y_continuous(\n    trans = scales::pseudo_log_trans(sigma = 1e-2),\n    breaks = c(0, 0.01, 0.1, 0.5, 1)\n    ) +\n  scale_color_brewer(type = \"qual\") +\n  labs(\n    y = \"Melampsora proportion\",\n    x = \"Mean efficiency\"\n  )\n\n\n\n\n\n(p1.1 + ggtitle(\"Distribution of the mean efficiency across samples\")) / \n  (p2.1 + ggtitle(\"Melampsora proportion vs. mean efficiency\")) +\n  plot_annotation(tag_levels = \"A\")\n\n\n\n\nTODO: Still need to determien if the y axis is accurate on histogram; I think its off when using pseudo-log. But perhaps can get away with linear?\nCheck errors in FCs\nWe can use this distribution to pick examples of samples where bias approximately cancels in the FC estimates (because their SMRE’s are similar), and samples where bias does not approximately cancel (because their SMRE’s are very different). Could do for mock samples (using the ground truth) or for natural samples (using the calibrated composition). Might as well do it both ways; not sure which would be best for a paper. The mocks have the benefit of knowing the ground truth, while the natural samples demonstrate practical significance. Also, we can give nice intuitive description of what we’re doing in the natural samples by saying that we’re comparing samples w/ low-low, high-high, or low-high pathogen %.\nTODO ^^\nmock samples\nTo pick from the mock samples:\n\n\nsme0 %>%\n  filter(Samp_type == \"Mock\") %>%\n  select(Sample, SMRE, Melampsora) %>%\n  arrange(SMRE) %>%\n  mutate(\n    log10_SMRE = log10(SMRE),\n    diff = c(NA, diff(log10_SMRE))\n  )\n\n\n# A tibble: 10 x 5\n   Sample   SMRE Melampsora log10_SMRE     diff\n   <chr>   <dbl>      <dbl>      <dbl>    <dbl>\n 1 Mock.3  0.541    0.00782   -0.267   NA      \n 2 Mock.7  0.970    0.00761   -0.0132   0.254  \n 3 Mock.9  0.981    0.0116    -0.00824  0.00492\n 4 Mock.2  1.16     0.0524     0.0628   0.0711 \n 5 Mock.6  1.24     0.0435     0.0931   0.0303 \n 6 Mock.10 1.82     0.0948     0.261    0.168  \n 7 Mock.1  2.00     0.0540     0.301    0.0400 \n 8 Mock.4  2.12     0.164      0.327    0.0256 \n 9 Mock.8  2.20     0.134      0.343    0.0161 \n10 Mock.5  2.96     0.179      0.472    0.129  \n\nMock.3 -> Mock.5 have the biggest difference in SMRE. Notably, its still only a factor of 5.5 difference.\nMock.7 -> Mock.9 have the smallest log difference.\nNext: Compute the actual and observed FC in proportions, for each of these pairs of communities. Perhaps define a function to spit out the relevant data frame, given any pair of samples, the phyloseq object (or calibrated phyloseq object?), and the bias vector? Actually, for the mocks, should use the “actual” table instead of calibrated.\nUse these objects,\n\n\nmock_actual\n\n\nOTU Table:          [ 9 taxa and 10 samples ]:\nTaxa are columns\n        Melampsora Dioszegia Epicoccum Fusarium Penicillium\nMock.1      0.0538    0.0108    0.0108   0.269       0.0108\nMock.2      0.0538    0.269     0.269    0.0108      0.0108\nMock.3      0.0108    0.269     0.0538   0.0108      0.269 \nMock.4      0.269     0.0538    0.0108   0.0538      0.269 \nMock.5      0.269     0.0108    0.0108   0.269       0.0538\nMock.6      0.0538    0.0538    0.0538   0.0108      0.0108\nMock.7      0.0108    0.269     0.0538   0.269       0.269 \nMock.8      0.269     0.0108    0.269    0.0538      0.0538\nMock.9      0.0108    0.0538    0.269    0.0538      0.0538\nMock.10     0.111     0.111     0.111    0.111       0.111 \n# … with 4 more taxa (columns)\n\nps.mock.pseudo\n\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:          [ 9 taxa and 10 samples ]:\nsample_data() Sample Data:        [ 10 samples by 16 sample variables ]:\ntax_table()   Taxonomy Table:     [ 9 taxa by 7 taxonomic ranks ]:\nrefseq()      DNAStringSet:       [ 9 reference sequences ]\ntaxa are columns\n\nWe can use metacal::pairwise_ratios() to compute the FCs in abundances between all samples + for all taxa, given a phyloseq object.\n\n\nfcs <- list(Actual = mock_actual, Observed = ps.mock.pseudo) %>%\n  map(transform_sample_counts, close_elts) %>%\n  map(pairwise_ratios, margin = \"samples\", filter = FALSE) %>%\n  map_dfr(psmelt, .id = \"Type\") %>%\n  # redo sample.1 and sample.2 since missing for the mock\n  select(-sample.1, -sample.2) %>%\n  rename(Pair = Sample, Fold_change = Abundance) %>%\n  separate(Pair, str_c(\"Sample.\", 1:2), sep = \":\", remove = FALSE) %>%\n  mutate(across(OTU, factor, levels = bias %>% sort %>% names)) %>%\n  left_join(sme0 %>% select(Sample.1 = Sample, SMRE, Melampsora), \n    by = \"Sample.1\") %>%\n  left_join(sme0 %>% select(Sample.2 = Sample, SMRE, Melampsora), \n    by = \"Sample.2\", suffix = c(\".1\", \".2\"))\n\n\n\n\n\nfcs %>%\n  filter(Pair %in% c(\"Mock.5:Mock.3\", \"Mock.9:Mock.7\")) %>%\n  ggplot(aes(y = OTU, x = Fold_change, shape = Type, color = Type)) +\n  facet_grid(. ~ Pair) +\n  scale_shape_manual(values = c(Actual = 3, Observed = 1)) +\n  scale_color_brewer(type = \"qual\", palette = 6) +\n  geom_vline(xintercept = 1, color = \"black\", size = 0.2) +\n  geom_point(size = 2) +\n  theme_minimal_hgrid() +\n  scale_x_log10(limits = c(3e-3, 1e2), oob = scales::squish) +\n  labs(x = \"Fold change in proportion\") +\n  plot_annotation(\n    title = \"Actual and observed fold changes between pairs of mocks\"\n  )\n\n\n\n\n\n\nggsave(\"/tmp/leopold2020-fc-mock-examples.png\", units = \"in\",\n  width = 6, height = 3, scale = 1.5)\n\n\n\nCan see that on the left, the error is positive for all taxa, and of a similar magnitude (on the order of ~6X, as predicted) for all taxa except for Epicoccum, which dropped out during sequencing in Mock.5; and on the right, the error is smaller and not consistently positive or negative. Sign errors correspond to the observed and actual fold changes being on opposing sides of the vertical red line at 1.\ntodo: add the SMRE changes to the facet labels, and perhaps mark the expected\nWhat other types of plots, which might use all pairs of samples?\nwe could plot the observed vs. predicted error\nwe could check that the error really is taxon independent; one way to do this is to calc the correlation in LFC between observed and actual\n\n\nlvls <- sme0 %>% arrange(SMRE) %>% pull(Sample)\nfcs0 <- fcs %>%\n  # filter(Sample.1 < Sample.2) %>%\n  select(Type:Fold_change, SMRE.1:Melampsora.2) %>%\n  pivot_wider(names_from = Type, values_from = Fold_change) %>%\n  mutate(across(c(Sample.1, Sample.2), factor, levels = lvls))\n\n\n\n\n\nfcs0 %>%\n  filter(as.integer(Sample.1) < as.integer(Sample.2)) %>%\n  ggplot(aes(Actual, Observed, color = OTU)) +\n  geom_abline(color = \"grey\") +\n  geom_point() +\n  scale_x_log10() +\n  scale_y_log10() +\n  facet_grid(Sample.1 ~ Sample.2) +\n  scale_color_brewer(type = \"qual\", palette = 3)\n\n\n\n\nNote how (especially) for Mock 1 and 6, the points follow a straight line with a greater slope than predicted. This seems likely related to the systematic deviation from the model that I observed.\nCheck that there is indeed very high correlations; remove the Epicoccum Mock-5 dropout first to avoid major distortions just from that.\n\n\ncorrs <- fcs0 %>%\n  filter(\n    Sample.1 != Sample.2,\n    !((Sample.1 == \"Mock.5\" | Sample.2 == \"Mock.5\") & OTU == \"Epicoccum\")\n  ) %>%\n  mutate(across(c(Actual, Observed), log10)) %>%\n  group_by(Pair) %>%\n  summarize(correlation = cor(Actual, Observed, method = \"pearson\"))\ncorrs %>% pull(correlation) %>% summary\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.9637  0.9827  0.9894  0.9874  0.9929  0.9989 \n\n# qplot(corrs$correlation)\n\n\n\nExperiment samples\nWe could just try picking a high and low Melampsora sample - perhaps from the mode of the peaks, rather than the extreme.\n\n\nsme0 %>%\n  filter(Samp_type == \"Experiment\") %>%\n  select(Sample, SMRE, Melampsora) %>%\n  arrange(SMRE) %>%\n  mutate(\n    log10_SMRE = log10(SMRE),\n    diff = c(NA, diff(log10_SMRE))\n  )\n\n\n# A tibble: 548 x 5\n   Sample         SMRE Melampsora log10_SMRE       diff\n   <chr>         <dbl>      <dbl>      <dbl>      <dbl>\n 1 G12.T6.R4.TP1 0.996  0.00182     -0.00185 NA        \n 2 G1.T5.R2.TP1  1.24   0.0000218    0.0939   0.0958   \n 3 G11.T2.R4.TP1 1.24   0.0000836    0.0951   0.00114  \n 4 G12.T1.R2.TP1 1.28   0.0000166    0.108    0.0128   \n 5 G12.T2.R4.TP1 1.28   0.0000309    0.108    0.000619 \n 6 G11.T3.R3.TP1 1.29   0.000253     0.110    0.00119  \n 7 G2.T2.R4.TP1  1.29   0.0000220    0.110    0.000570 \n 8 G8.T4.R1.TP1  1.29   0.0000132    0.110    0.0000354\n 9 G9.T5.R3.TP1  1.29   0.0000714    0.110    0.000185 \n10 G4.T6.R3.TP1  1.29   0.000197     0.112    0.00139  \n# … with 538 more rows\n\nSession info\n\nClick for session info\n\n\nsessioninfo::session_info()\n\n\n─ Session info ──────────────────────────────────────────────────────────────────\n setting  value                       \n version  R version 4.0.5 (2021-03-31)\n os       Arch Linux                  \n system   x86_64, linux-gnu           \n ui       X11                         \n language (EN)                        \n collate  en_US.UTF-8                 \n ctype    en_US.UTF-8                 \n tz       America/New_York            \n date     2021-04-21                  \n\n─ Packages ──────────────────────────────────────────────────────────────────────\n package      * version    date       lib source                           \n ade4           1.7-16     2020-10-28 [1] CRAN (R 4.0.3)                   \n ape            5.4-1      2020-08-13 [1] CRAN (R 4.0.2)                   \n assertthat     0.2.1      2019-03-21 [1] CRAN (R 4.0.0)                   \n backports      1.2.1      2020-12-09 [1] CRAN (R 4.0.3)                   \n beeswarm       0.3.1      2021-03-07 [1] CRAN (R 4.0.5)                   \n Biobase        2.50.0     2020-10-27 [1] Bioconductor                     \n BiocGenerics   0.36.0     2020-10-27 [1] Bioconductor                     \n biomformat     1.18.0     2020-10-27 [1] Bioconductor                     \n Biostrings     2.58.0     2020-10-27 [1] Bioconductor                     \n broom          0.7.6      2021-04-05 [1] CRAN (R 4.0.5)                   \n bslib          0.2.4      2021-01-25 [1] CRAN (R 4.0.4)                   \n cellranger     1.1.0      2016-07-27 [1] CRAN (R 4.0.0)                   \n cli            2.4.0      2021-04-05 [1] CRAN (R 4.0.5)                   \n cluster        2.1.1      2021-02-14 [2] CRAN (R 4.0.5)                   \n codetools      0.2-18     2020-11-04 [2] CRAN (R 4.0.5)                   \n colorspace     2.0-0      2020-11-11 [1] CRAN (R 4.0.3)                   \n cowplot      * 1.1.1      2020-12-30 [1] CRAN (R 4.0.4)                   \n crayon         1.4.1      2021-02-08 [1] CRAN (R 4.0.4)                   \n data.table     1.14.0     2021-02-21 [1] CRAN (R 4.0.4)                   \n DBI            1.1.1      2021-01-15 [1] CRAN (R 4.0.4)                   \n dbplyr         2.1.1      2021-04-06 [1] CRAN (R 4.0.5)                   \n digest         0.6.27     2020-10-24 [1] CRAN (R 4.0.3)                   \n distill        1.2.4      2021-04-05 [1] Github (rstudio/distill@3ec93f1) \n downlit        0.2.1      2020-11-04 [1] CRAN (R 4.0.3)                   \n dplyr        * 1.0.5      2021-03-05 [1] CRAN (R 4.0.4)                   \n ellipsis       0.3.1      2020-05-15 [1] CRAN (R 4.0.0)                   \n evaluate       0.14       2019-05-28 [1] CRAN (R 4.0.0)                   \n fansi          0.4.2      2021-01-15 [1] CRAN (R 4.0.3)                   \n farver         2.1.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n forcats      * 0.5.1      2021-01-27 [1] CRAN (R 4.0.4)                   \n foreach        1.5.1      2020-10-15 [1] CRAN (R 4.0.3)                   \n fs             1.5.0      2020-07-31 [1] CRAN (R 4.0.2)                   \n generics       0.1.0      2020-10-31 [1] CRAN (R 4.0.3)                   \n ggbeeswarm   * 0.6.0      2017-08-07 [1] CRAN (R 4.0.0)                   \n ggplot2      * 3.3.3      2020-12-30 [1] CRAN (R 4.0.4)                   \n glue           1.4.2      2020-08-27 [1] CRAN (R 4.0.2)                   \n gtable         0.3.0      2019-03-25 [1] CRAN (R 4.0.0)                   \n haven          2.3.1      2020-06-01 [1] CRAN (R 4.0.1)                   \n here           1.0.1      2020-12-13 [1] CRAN (R 4.0.3)                   \n highr          0.8        2019-03-20 [1] CRAN (R 4.0.0)                   \n hms            1.0.0      2021-01-13 [1] CRAN (R 4.0.4)                   \n htmltools      0.5.1.1    2021-01-22 [1] CRAN (R 4.0.3)                   \n httr           1.4.2      2020-07-20 [1] CRAN (R 4.0.2)                   \n igraph         1.2.6      2020-10-06 [1] CRAN (R 4.0.3)                   \n IRanges        2.24.1     2020-12-12 [1] Bioconductor                     \n iterators      1.0.13     2020-10-15 [1] CRAN (R 4.0.3)                   \n jquerylib      0.1.3      2020-12-17 [1] CRAN (R 4.0.4)                   \n jsonlite       1.7.2      2020-12-09 [1] CRAN (R 4.0.3)                   \n knitr          1.31       2021-01-27 [1] CRAN (R 4.0.3)                   \n lattice        0.20-41    2020-04-02 [2] CRAN (R 4.0.5)                   \n lifecycle      1.0.0      2021-02-15 [1] CRAN (R 4.0.4)                   \n lubridate      1.7.10     2021-02-26 [1] CRAN (R 4.0.4)                   \n magrittr       2.0.1      2020-11-17 [1] CRAN (R 4.0.3)                   \n MASS           7.3-53.1   2021-02-12 [2] CRAN (R 4.0.5)                   \n Matrix         1.3-2      2021-01-06 [2] CRAN (R 4.0.5)                   \n metacal      * 0.2.0      2021-04-21 [1] Github (mikemc/metacal@cf3a3c7)  \n mgcv           1.8-34     2021-02-16 [2] CRAN (R 4.0.5)                   \n modelr         0.1.8      2020-05-19 [1] CRAN (R 4.0.0)                   \n multtest       2.46.0     2020-10-27 [1] Bioconductor                     \n munsell        0.5.0      2018-06-12 [1] CRAN (R 4.0.0)                   \n nlme           3.1-152    2021-02-04 [2] CRAN (R 4.0.5)                   \n nvimcom      * 0.9-102    2021-04-05 [1] local                            \n patchwork    * 1.1.1      2020-12-17 [1] CRAN (R 4.0.3)                   \n permute        0.9-5      2019-03-12 [1] CRAN (R 4.0.0)                   \n phyloseq     * 1.34.0     2020-10-27 [1] Bioconductor                     \n pillar         1.6.0      2021-04-13 [1] CRAN (R 4.0.5)                   \n pkgconfig      2.0.3      2019-09-22 [1] CRAN (R 4.0.0)                   \n plyr           1.8.6      2020-03-03 [1] CRAN (R 4.0.0)                   \n prettyunits    1.1.1      2020-01-24 [1] CRAN (R 4.0.0)                   \n progress       1.2.2      2019-05-16 [1] CRAN (R 4.0.2)                   \n ps             1.6.0      2021-02-28 [1] CRAN (R 4.0.4)                   \n purrr        * 0.3.4      2020-04-17 [1] CRAN (R 4.0.0)                   \n R6             2.5.0      2020-10-28 [1] CRAN (R 4.0.3)                   \n RColorBrewer   1.1-2      2014-12-07 [1] CRAN (R 4.0.0)                   \n Rcpp           1.0.6      2021-01-15 [1] CRAN (R 4.0.3)                   \n readr        * 1.4.0      2020-10-05 [1] CRAN (R 4.0.3)                   \n readxl         1.3.1      2019-03-13 [1] CRAN (R 4.0.0)                   \n reprex         2.0.0      2021-04-02 [1] CRAN (R 4.0.5)                   \n reshape2       1.4.4      2020-04-09 [1] CRAN (R 4.0.0)                   \n rhdf5          2.34.0     2020-10-27 [1] Bioconductor                     \n rhdf5filters   1.2.0      2020-10-27 [1] Bioconductor                     \n Rhdf5lib       1.12.1     2021-01-26 [1] Bioconductor                     \n rlang          0.4.10     2020-12-30 [1] CRAN (R 4.0.3)                   \n rmarkdown    * 2.7        2021-02-19 [1] CRAN (R 4.0.4)                   \n rprojroot      2.0.2      2020-11-15 [1] CRAN (R 4.0.3)                   \n rstudioapi     0.13       2020-11-12 [1] CRAN (R 4.0.3)                   \n rvest          1.0.0      2021-03-09 [1] CRAN (R 4.0.5)                   \n S4Vectors      0.28.1     2020-12-09 [1] Bioconductor                     \n sass           0.3.1      2021-01-24 [1] CRAN (R 4.0.4)                   \n scales         1.1.1      2020-05-11 [1] CRAN (R 4.0.0)                   \n sessioninfo    1.1.1      2018-11-05 [1] CRAN (R 4.0.0)                   \n speedyseq    * 0.5.3.9001 2020-10-06 [1] Github (mikemc/speedyseq@8daed32)\n stringi        1.5.3      2020-09-09 [1] CRAN (R 4.0.3)                   \n stringr      * 1.4.0      2019-02-10 [1] CRAN (R 4.0.0)                   \n survival       3.2-10     2021-03-16 [2] CRAN (R 4.0.5)                   \n tibble       * 3.1.1      2021-04-18 [1] CRAN (R 4.0.5)                   \n tidyr        * 1.1.3      2021-03-03 [1] CRAN (R 4.0.4)                   \n tidyselect     1.1.0      2020-05-11 [1] CRAN (R 4.0.0)                   \n tidyverse    * 1.3.0      2019-11-21 [1] CRAN (R 4.0.0)                   \n useful         1.2.6      2018-10-08 [1] CRAN (R 4.0.0)                   \n utf8           1.2.1      2021-03-12 [1] CRAN (R 4.0.5)                   \n vctrs          0.3.7      2021-03-29 [1] CRAN (R 4.0.5)                   \n vegan          2.5-7      2020-11-28 [1] CRAN (R 4.0.3)                   \n vipor          0.4.5      2017-03-22 [1] CRAN (R 4.0.0)                   \n withr          2.4.2      2021-04-18 [1] CRAN (R 4.0.5)                   \n xfun           0.22       2021-03-11 [1] CRAN (R 4.0.5)                   \n xml2           1.3.2      2020-04-23 [1] CRAN (R 4.0.0)                   \n XVector        0.30.0     2020-10-27 [1] Bioconductor                     \n yaml           2.2.1      2020-02-01 [1] CRAN (R 4.0.0)                   \n zlibbioc       1.36.0     2020-10-27 [1] Bioconductor                     \n\n[1] /home/michael/R/x86_64-pc-linux-gnu-library/4.0\n[2] /usr/lib/R/library\n\n\n\n\nLeopold, Devin R, and Posy E Busby. 2020. “Host Genotype and Colonist Arrival Order Jointly Govern Plant Microbiome Composition and Function.” Curr. Biol. 30 (16): 3260–3266.e5. https://doi.org/10.1016/j.cub.2020.06.011.\n\n\n\n\n",
    "preview": "posts/2020-11-12-leopold2020host-bias-sensitivity/index_files/figure-html5/unnamed-chunk-3-1.svg",
    "last_modified": "2021-09-15T14:18:05-04:00",
    "input_file": {}
  }
]
